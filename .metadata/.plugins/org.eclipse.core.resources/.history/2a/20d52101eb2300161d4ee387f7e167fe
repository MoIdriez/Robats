/*
 * GamePad.cpp
 *
 *  Created on: 25 May 2016
 *      Author: midries
 */

#include "GamePad.h"
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>

GamePad::GamePad() {
	gamepad_fd = open(GAMEPAD_DEVNAME, O_RDONLY | O_NONBLOCK); /* read write for force feedback? */
	if (gamepad_fd < 0)
		throw "Couldn't open gamepad";
}

int GamePad::readValues(struct gp_values *gpv) {
	struct gp_event gpe;
	if (readEvent(&gpe) == 1) {
		gpe.type &= ~GP_EVENT_INIT; /* ignore synthetic events */
		if (gpe.type == GP_EVENT_AXIS) {
			switch (gpe.number) {
			case YAW:
				gpv->yaw = convert(gpe.value, GP_AXIS_MIN, GP_AXIS_MAX, -199, 199);/* Range -199- 199 */
				break;
			case PITCH:
				gpv->pitch = convert(gpe.value, GP_AXIS_MIN, GP_AXIS_MAX, -30, 30);;/* Range -30 - 30 */
				break;
			case ROLL:
				gpv->roll = convert(gpe.value, GP_AXIS_MIN, GP_AXIS_MAX, -30, 30);;/* Range -30 - 30 */
				break;
			case THRUST:
				gpv->thrust = convert(gpe.value, GP_AXIS_MIN, GP_AXIS_MAX, 0, 100);;/* Range 0 - 100 */
				break;
			default:
				break;
			}
		}

	} else {
		//printf("Couldn't read event\n");
	}
}

short GamePad::convert(short oldValue, short oldMin, short oldMax, short newMin, short newMax) {
	short oldRange = oldMax - oldMin;
	short newRange = newMax - newMin;
	return (((oldValue - oldMin) * newRange) / oldRange) + newMin;
}

int GamePad::readEvent(struct gp_event *jse) {
	int bytes;
	bytes = read(gamepad_fd, jse, sizeof(*jse));

	if (bytes == -1)
		return 0;

	if (bytes == sizeof(*jse))
		return 1;

	printf("Unexpected bytes from gamepad:%d\n", bytes);
    return -1;
}

GamePad::~GamePad() {
	close(gamepad_fd);
}



